<!DOCTYPE html>
<html>
<header>
    <h2>Unidade3</h2>
</header>

<body>

    <input type="file" id="inputCSV" onchange="pegaCSV(this)">
    <div id="CSVsaida"></div>
    <div id="exibeResultado"></div>

    <script>
        let array = []
        
        function copiaVetor(veto1) {
            let i
            let vetor2 = new Array(veto1.length)
            for (i = 0; i < veto1.length; i++) {
                vetor2[i] = veto1[i]
            }
            return vetor2
        }

        function somarCustoCaminho(matriz, caminho) {
            let i, j, k
            let soma = 0
            //console.log("caminhoLENGTH: ", caminho.length)
            //console.log("caminho: ", caminho)
            for (i = 0; i <= caminho.length - 2; i++) {
                //console.log("caminho: ", caminho[i])
                j = caminho[i]
                //console.log("caminho[i] ", caminho[i] )
                k = caminho[i + 1]
                //console.log("i: ", i, " j: ",j," k: ", k)
                try{
                    soma += matriz[j][k]
                }catch(e){
                    console.log("ERROR: ",e,"\ni: ",i," j: "," k: ",k, "caminho: ",caminho)
                }
                
            }
            return soma
        }
        /*
        function minCaminho(matriz,tam){
            let S = 0, min = Number.MAX_VALUE, custoMenorCaminho = []
            let linha = 0, caminho = [], cidadeVisitada = 0
            var i=0,j=0

            caminho.push(0)
            for (S = 0; S < tam-1; S++) {
                    //for (j = linha + 1; j <= tam; j++) { //controle para percorrer o triangulo superior da matriz(coluna) 
                    for (j = 1; j < tam; j++) {//escolho a cidade 0 como inicio
                        if ((matriz[i][j] < min) && (matriz[i][j] != 0) && (caminho.includes(j) == false)) {
                            
                                min = matriz[i][j]
                                cidadeVisitada = j
                        }
                        if(j == (tam-1)){ //ja tenho o menor caminho
                            if(caminho.includes(cidadeVisitada) == false){ //so percorre uma cidade se ela nao foi visitada
                                caminho.push(cidadeVisitada)
                                custoMenorCaminho.push(min)
                                i = cidadeVisitada

                                if(S==(tam-2)){ //ultima cidade visitada
                                    min = matriz[i][0]
                                    custoMenorCaminho.push(min)
                                    caminho.push(0)
                                }
                            }
                        }
                    }
                //console.log("caminho: ", caminho)
                min = Number.MAX_VALUE
            }
            
            //console.log("custoMenorCaminho: ", custoMenorCaminho)

            //console.log("menorCaminho: ", menorCaminho)
            var somaMenorCaminho = 0
            for (i = 0; i < custoMenorCaminho.length; i++) {
                somaMenorCaminho += custoMenorCaminho[i]
            }
            //console.log("somaMin: ", somaMenorCaminho)
            let retorno = []
            //retorno = caminho
            retorno.push(caminho,somaMenorCaminho)
            //exibeResultado(somaMenorCaminho)
            //console.log("caminhoMin: ",retorno)
            return retorno
        }
        /*
        function maxCaminho(matriz, tam) {
                let S = 0, max = 0, custoMaiorCaminho = []
                let linha = 0, caminho = [], cidadeVisitada = 0
                var i = 0, j = 0
                caminho.push(0)
                for (S = 0; S < tam - 1; S++) { // cidades
                    //for (j = linha + 1; j <= tam; j++) { //controle para percorrer o triangulo superior da matriz(coluna) 
                    for (j = 1; j < tam; j++) {//escolho a cidade 0 como inicio
                        if ((matriz[i][j] > max) && (matriz[i][j] != 0) && (caminho.includes(j) == false)) {

                            max = matriz[i][j]
                            cidadeVisitada = j
                        }
                        if (j == (tam - 1)) { //ja tenho o menor caminho
                            if (caminho.includes(cidadeVisitada) == false) { //so percorre uma cidade se ela nao foi visitada
                                caminho.push(cidadeVisitada)
                                custoMaiorCaminho.push(max)
                                i = cidadeVisitada

                                if (S == (tam - 2)) { //ultima cidade visitada
                                    max = matriz[i][0]
                                    custoMaiorCaminho.push(max)
                                    caminho.push(0)
                                }
                            }
                        }
                    }
                    //console.log("caminho: ", caminho)

                    linha++
                    max = 0
                }
                //console.log("custoMaiorCaminho: ", custoMaiorCaminho)

                //console.log("menorCaminho: ", menorCaminho)
                var somaMaiorCaminho = 0
                for (i = 0; i < custoMaiorCaminho.length; i++) {
                    somaMaiorCaminho += custoMaiorCaminho[i]
                }
                //console.log("somaMax: ", somaMaiorCaminho)

                //exibeResultado(somaMenorCaminho)

                let retorno = []
                retorno.push(caminho,somaMaiorCaminho)
                return retorno
             
            }

        

        function caminhoMaisBarato(matriz, tam){
            let S = 0, min = Number.MAX_VALUE, custoCaminhoMaisBarato = []
            let linha = 0, caminho = [], cidadesNAOvisitadas = [], cidadeVisitada = 0, somaCusto = 0
            var i = 0, j = 1, l=0,k

            for(k=0;k<tam;k++){
                cidadesNAOvisitadas[k] = k 
            }
            //console.log("cidadesNAOvisitadas: ",cidadesNAOvisitadas)
            caminho.push(0)
            cidadesNAOvisitadas.splice(0,1)
            //for (S = 0; S < tam - 1; S++) {
                //for (i = 0; i < tam; i++) { //controle para percorrer o triangulo superior da matriz(coluna) 
            
            //======================================PASSO1======================================
            for (j = 1; j < tam; j++) {//escolho a cidade 0 como inicio, //escolhe a cidade mais próxima para ser visitado
                //if(l==0){ 
                    if ((matriz[i][j] < min) && (matriz[i][j] != 0) && (caminho.includes(j) == false)) {//so percorre uma cidade se ela nao foi visitada
                        min = matriz[i][j]
                        cidadeVisitada = j
                    }
                    if (j == (tam - 1)) { //ja tenho o menor caminho
                        caminho.push(cidadeVisitada)//insiro a cidade visitada no array
                        //console.log("j: ", cidadeVisitada)
                        cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitada), 1)
                        //console.log("cidadesNAOvisitadas: ", cidadesNAOvisitadas)
                        custoCaminhoMaisBarato.push(min)  
                    }
                    
            }
            //console.log("caminho_PASSO1: ", caminho)
            //console.log("cidadesNAOvisitadas_PASSO1: ", cidadesNAOvisitadas)
            //=================================FIM==PASSO1======================================

            //======================================PASSO2======================================
            min = Number.MAX_VALUE
            let minAux = 0
            for (S = 0; S < tam - 1; S++) {//percorrer as cidades
                for (j = 0; j < tam; j++){//colunas
                    minAux = matriz[j][caminho[0]] + matriz[caminho[1]][j]
                    if ((minAux < min) && (minAux != 0) && (caminho.includes(j) == false)) {//saber as cidadesNAOvisitadas ja percorridas para somar o custo e posteriormente buscar o custo minimo    //so percorre uma cidade se ela nao foi visitada
                        min = minAux
                        cidadeVisitada = j
                            /*console.log("cidadesVisitadasFORJ: ", cidadeVisitada)
                            console.log("custoMIN: ", custoMin, " i: ",i, " j: ",j) */
    /*                }
                }
                if (S == (tam - 2)) { //ultima cidade visitada
                    caminho.push(cidadeVisitada)//insiro a cidade visitada no array
                    caminho.push(0)//fechando o ciclo ->voltando para a cidade origem
                    cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitada), 1)
                    //custoCaminhoMaisBarato.push(custoMin)
                    //console.log("cidadesVisitadasIFS: ", cidadeVisitada)
                }
            }
            //console.log("caminho_PASSO2: ", caminho)
            //console.log("cidadesNAOvisitadas_PASSO2: ", cidadesNAOvisitadas)
            
            //=================================FIM==PASSO2======================================
            
            //======================================PASSO3======================================
            min = Number.MAX_VALUE
            minAux = 0
            //console.log("caminho: ",caminho.length)
            var cidadesNAOvisitadasAux = cidadesNAOvisitadas.length
            let cidadei, cidadej

            for (S = 0; S < cidadesNAOvisitadasAux; S++) {//percorrer as cidades
                for(l=0; l<caminho.length-1; l++){
                    i = caminho[l]
                    j = caminho[l + 1]
                    //console.log("l: ",l)
                    
                    for(m=0;m<cidadesNAOvisitadas.length;m++){
                        k = cidadesNAOvisitadas[m]
                        
                        minAux = (matriz[i][k] + matriz[k][j]) - matriz[i][j]
                        
                        if (minAux < min) {
                            //console.log("# i: ", i, " j: ", j, " k: ", k)
                            min = minAux
                            cidadeVisitada = k
                            cidadei = i
                            cidadej = j

                            //console.log("min_PASSO3: ", min, " i: ",i," j: ",j, " k: ",k)
                        }   
                    }
                }
                //console.log("cidadei: ",cidadei, " cidadej: ",cidadej, " k: ", cidadeVisitada)
                caminho.splice(caminho.indexOf(cidadei)+1,0, cidadeVisitada)
                //console.log("MATRIZ[ik]: ",matriz[cidadei][cidadeVisitada], " MATRIZ[kj]: ", matriz[cidadeVisitada][cidadej], " MATRIZ[ij]: ", matriz[cidadei][cidadej])
                //console.log("S: ",S, " - min_PASSO3: ", min, "cidade visitada: ",cidadeVisitada)
                
                cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitada), 1)
                min = Number.MAX_VALUE
            }
            //console.log("cidadeVisitada_PASSO3: ", cidadeVisitada)
            
            var somaCaminhoMaisBarato = 0
            
            for(i=0;i<caminho.length-1;i++){
                j = caminho[i]
                k = caminho[i+1]
                somaCaminhoMaisBarato += matriz[j][k]
            }
            //console.log("caminho_PASSO3: ", caminho)
            //=================================FIM==PASSO3======================================
            
            //console.log("somaCaminhoMaisBarato: ", somaCaminhoMaisBarato)
            //exibeResultado(somaMenorCaminho)
            let retorno = []
            retorno.push(caminho,somaCaminhoMaisBarato)
            //retorno.push(somaCaminhoMaisBarato)
            //console.log("caminho: ", caminho, "custo: ", somaCaminhoMaisBarato)
            //return somaCaminhoMaisBarato, caminho
            return retorno
        }
        /*
        function minCaminhoAleatorio(matriz, tam) {
            let S = 0, min = Number.MAX_VALUE, custoMenorCaminho = []
            let linha = 0, caminho = [], cidadeVisitada = 0
            var i,j
            caminho.push(0)

            //Math.floor(Math.random() * 100);     // returns a random integer from 0 to 99
            /*
            i = 0
            j = Math.floor(Math.random() * tam)
            //console.log("j: ", j)
            while(caminho.length < tam){
                
                if(caminho.includes(j) == false && (matriz[i][j] < min)){
                    cidadeVisitada = j
                    caminho.push(cidadeVisitada)
                    i = cidadeVisitada
                    
                    console.log("caminho: ",caminho)
                    min = Number.MAX_VALUE
                }
                j = Math.floor(Math.random() * tam)
                
            }
            */


            //volta pra cidade natal
            /*
            caminho.push(0)

            somaMenorCaminho = somarCustoCaminho(matriz,caminho) 

            let retorno = []
            retorno.push(caminho, somaMenorCaminho)
            //exibeResultado(somaMenorCaminho)
            //console.log("caminhoMin: ",retorno)
            return retorno
        }
        */
        function minCaminhoAleatorio2(matriz, tam) {
                let S = 0, min = Number.MAX_VALUE, custoMenorCaminho = [], somaMenorCaminho
                let indice, indiceEscolhido, caminho = [], menorCaminho = [], custoij = [], cidadesVisitadas= [], cidadeVisitada = 0
                var i = 0, j = 0,l,m = 0
                let aux = 0

                caminho.push(0)
                //while(caminho.length < tam){
                for (S = 1; S < tam; S++) {
                    for (j = 0; j < tam; j++) {//escolho a cidade 0 como inicio
                        if (i != j && caminho.includes(j) == false) {
                            aux = matriz[i][j]
                            //console.log("aux: ", aux)
                            custoij.push(aux)
                        }

                    }

                    //console.log("i: ",i)
                    //ordenar o array de custos do menor elemento para o maior e depois ver o caminho
                    //console.log("Custoij: ", custoij)
                    custoij.sort(function (a, b) { return a - b });
                    //custoij.sort();
                    //console.log("sortCusto: ", custoij)
                    //console.log("Custo.length: ", custoij.length)

                    //saber o indice entre as cidades desses custo ordenados na matriz 
                    //console.log("caminhoijANTES DO FOR: ", caminhoij)
                    for (m = 0; m < custoij.length; m++) {
                        for (j = 1; j < matriz.length; j++) {
                            //console.log("m: ", m, "j: ",j, "l: ",l)
                            if (custoij[m] == matriz[i][j] && caminho.includes(j) == false) { //capturar o indice do valor ordenado
                                cidadeVisitada = j
                                cidadesVisitadas.push(cidadeVisitada)

                                //console.log("cidadesVisitadas_IF: ", cidadesVisitadas)
                            }
                        }

                    }
                    //console.log("SAI 2FOR")
                    //indices iniciais do caminhoij sao os mais pertos da cidade onde estou
                    indice = parseInt((cidadesVisitadas.length / 2), 10) //indice da metade do vetor
                    //console.log("indice", indice)

                    //rand do indice para capturar o elemento a ser inserido no array CAMINHO
                    //Math.floor(Math.random() * 100);     // returns a random integer from 0 to 99
                    indiceEscolhido = Math.floor(Math.random() * indice);
                    //console.log("caminhoij: ", caminhoij)
                    //console.log("indiceEscolhido", caminhoij[indiceEscolhido])

                    //inserir o indice no array Final
                    //if (caminho.includes(cidadesVisitadas[indiceEscolhido]) == false) {
                        caminho.push(cidadesVisitadas[indiceEscolhido])
                        
                        i = cidadesVisitadas[indiceEscolhido]
                        //console.log("i_IF: ", i)
                        
                        cidadesVisitadas = []
                        //cidadesVisitadas.push(i)
                        
                    //}
                    if(S == tam-1){ //ultima cidade visitada -> voltar pra cidade inicial
                        caminho.push(0)
                    }

                    //console.log("caminho", caminho)
                    custoij = []
                    
                }

            somaMenorCaminho = somarCustoCaminho(matriz, caminho)

            let retorno = []
            retorno.push(caminho, somaMenorCaminho)
            return retorno                
        }

        function maxCaminhoAleatorio2(matriz, tam) {
            let S = 0, max = 0, custoMenorCaminho = [], somaCustoCaminho
            let indice, indiceEscolhido, caminho = [], menorCaminho = [], custoij = [], cidadesVisitadas = [], cidadeVisitada = 0
            var i = 0, j = 0, l, m = 0
            let aux = 0

            caminho.push(0)
            //while(caminho.length < tam){
            for (S = 1; S < tam; S++) {
                for (j = 0; j < tam; j++) {//escolho a cidade 0 como inicio
                    if (i != j && caminho.includes(j) == false) {
                        aux = matriz[i][j]
                        //console.log("aux: ", aux)
                        custoij.push(aux)
                    }

                }

                //console.log("i: ",i)
                //ordenar o array de custos do maior elemento para o menor e depois ver o caminho
                //console.log("Custoij: ", custoij)
                //custoij.sort(function (a, b) { return a - b });
                custoij.sort(function (a, b) { return a - b });
                custoij.reverse()
                //console.log("sortCusto: ", custoij)
                //console.log("Custo.length: ", custoij.length)

                //saber o indice entre as cidades desses custo ordenados na matriz 
                //console.log("caminhoijANTES DO FOR: ", caminhoij)
                for (m = 0; m < matriz.length; m++) {
                    for (j = 1; j < matriz.length; j++) {
                        //console.log("m: ", m, "j: ",j, "l: ",l)
                        if (custoij[m] == matriz[i][j] && caminho.includes(j) == false) { //capturar o indice do valor ordenado
                            cidadeVisitada = j
                            cidadesVisitadas.push(cidadeVisitada)

                            //console.log("cidadesVisitadas_IF: ", cidadesVisitadas)
                        }
                    }

                }
                //console.log("SAI 2FOR")
                //indices iniciais do caminhoij sao os mais pertos da cidade onde estou
                indice = parseInt((cidadesVisitadas.length / 2), 10) //indice da metade do vetor
                //console.log("indice", indice)

                //rand do indice para capturar o elemento a ser inserido no array CAMINHO
                //Math.floor(Math.random() * 100);     // returns a random integer from 0 to 99
                indiceEscolhido = Math.floor(Math.random() * indice);
                //console.log("cidadesVisitadas: ", cidadesVisitadas)
                //console.log("indiceEscolhido", cidadesVisitadas[indiceEscolhido])

                //inserir o indice no array Final
                //if (caminho.includes(cidadesVisitadas[indiceEscolhido]) == false) {
                caminho.push(cidadesVisitadas[indiceEscolhido])
                
                //vou para a cidade visitada
                i = cidadesVisitadas[indiceEscolhido]
                //console.log("i_IF: ", i)

                cidadesVisitadas = []
                //cidadesVisitadas.push(i)

                //}
                if (S == tam - 1) { //ultima cidade visitada -> voltar pra cidade inicial
                    caminho.push(0)
                }

                //console.log("caminho", caminho)
                custoij = []

            }

            somaCustoCaminho = somarCustoCaminho(matriz, caminho)

            let retorno = []
            retorno.push(caminho, somaCustoCaminho)
            return retorno
        }
        /*
        function maxCaminhoAlatorio(matriz, tam) {
            let S = 0, max = 0, custoMaiorCaminho = []
            let linha = 0, caminho = [], cidadeVisitada = 0
            var i, j

            caminho.push(0)
            i = 0,
            j = Math.floor(Math.random() * tam)
            while (caminho.length < tam) {

                if (caminho.includes(j) == false && (matriz[i][j] > max)) {
                    cidadeVisitada = j
                    caminho.push(cidadeVisitada)
                    i = cidadeVisitada
                    max = 0
                }
                j = Math.floor(Math.random() * tam)

            }

            //volta pra cidade natal
            caminho.push(0)

            somaMaiorCaminho = somarCustoCaminho(matriz, caminho) 
            
            let retorno = []
            retorno.push(caminho, somaMaiorCaminho)
            return retorno

        }
        */
        function caminhoMaisBaratoAleatorio(matriz, tam) {
            let S = 0, min = Number.MAX_VALUE, custoCaminhoMaisBarato = []
            let linha = 0, caminho = [], cidadesNAOvisitadas = [], cidadeVisitada = 0, somaCusto = 0, cidadeVisitadaAux = []
            var i = 0, j = 1, l = 0, m =0, k, custo = [], indice, indiceEscolhido, indicesEscolhidos = []

            for (k = 0; k < tam; k++) {
                cidadesNAOvisitadas[k] = k
            }
            //console.log("cidadesNAOvisitadas: ",cidadesNAOvisitadas)
            caminho.push(0)
            cidadesNAOvisitadas.splice(0, 1) //tira o 0 da cidade nao visitada
            //for (S = 0; S < tam - 1; S++) {
            //for (i = 0; i < tam; i++) { //controle para percorrer o triangulo superior da matriz(coluna) 

            //======================================PASSO1======================================
            //ADICIONAR UMA DAS CIDADES ALEATORIAMENTE DE MENORES DISTANCIAS AO CAMINHO
            for (j = 1; j < tam; j++) {//escolho a cidade 0 como inicio, //escolhe a cidade mais próxima para ser visitado
                //if(l==0){ 
                if (/*(matriz[i][j] < min) &&*/ (matriz[i][j] != 0) && (caminho.includes(j) == false)) {//so percorre uma cidade se ela nao foi visitada
                    //saber todos os custos entre a cidade inicial e as outras
                    custo.push(matriz[i][j])
                    //min = matriz[i][j]
                    //cidadeVisitada = j
                }
                
                /*if (j == (tam - 1)) { //ja tenho o menor caminho
                    caminho.push(cidadeVisitada)//insiro a cidade visitada no array
                    //console.log("j: ", cidadeVisitada)
                    cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitada), 1)
                    //console.log("cidadesNAOvisitadas: ", cidadesNAOvisitadas)
                    //custoCaminhoMaisBarato.push(min)
                }*/
            }

            //ordenar os custos do menor para o maior 
            //console.log("custo_1<: ", custo)
            custo.sort(function (a, b) { return a - b });
            //console.log("custo_1>: ", custo)

            i=0
            //saber os indices dos custos (cidades) na matriz
            for (m = 0; m < custo.length; m++) {
                for (j = 1; j < matriz.length; j++) {
                    //console.log("m: ", m, "j: ",j, "l: ",l)
                    if (custo[m] == matriz[i][j] && caminho.includes(j) == false) { //capturar o indice do valor ordenado
                        cidadeVisitada = j
                        cidadeVisitadaAux.push(cidadeVisitada)

                        //console.log("cidadesVisitadas_IF: ", cidadesVisitadas)
                    }
                }

            }
            //console.log("SAI 2FOR")
            //indices iniciais do caminhoij sao os mais pertos da cidade onde estou
            indice = parseInt((cidadeVisitadaAux.length / 2), 10) //indice da metade do vetor
            //console.log("indice", indice)

            //rand do indice para capturar o elemento a ser inserido no array CAMINHO
            //capturar um dos menores custos aleatoriamente
            //Math.floor(Math.random() * 100);     // returns a random integer from 0 to 99
            indiceEscolhido = Math.floor(Math.random() * indice);
            //console.log("cidadesVisitadas: ", cidadesVisitadas)
            //console.log("indiceEscolhido", cidadesVisitadas[indiceEscolhido])

            //inserir o indice(cidade) no array de caminho Final
            //if (caminho.includes(cidadesVisitadas[indiceEscolhido]) == false) {
            caminho.push(cidadeVisitadaAux[indiceEscolhido])
            
            //Tirar a cidade escolhida do array de cidades nao visitadas
            cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitadaAux[indiceEscolhido]), 1)

            //console.log("caminho_PASSO1: ", caminho)
            //console.log("cidadesNAOvisitadas_PASSO1: ", cidadesNAOvisitadas)
            //=================================FIM==PASSO1======================================

            //======================================PASSO2======================================
            //ESCOLHER ENTRE AS CIDADES AQUELA CUJA AS DISTANCIAS ENTRE A CIDADE 0 E A ESCOLHIDA EH UMA 
            //DAS MENORES
            min = Number.MAX_VALUE
            let minAux = 0
            custo = []
            cidadeVisitadaAux = []
            i=0
            
            //for (S = 0; S < tam - 1; S++) {//percorrer as cidades
                //console.log("custo_ANTES_FOR: ", custo)
            for (j = 0; j < tam; j++) {//colunas
                //minAux = matriz[j][caminho[0]] + matriz[caminho[1]][j]
                //capturar todos os custos para analise
                //ce = cidade escohlida
                if(matriz[0][j] !=0 && (caminho.includes(j) == false)){
                    //             dce-0              +    d1-ce             
                    custo.push(matriz[j][caminho[0]] + matriz[caminho[1]][j])
                }
                
                
                /*if ((minAux < min) && (minAux != 0) && (caminho.includes(j) == false)) {//saber as cidadesNAOvisitadas ja percorridas para somar o custo e posteriormente buscar o custo minimo    //so percorre uma cidade se ela nao foi visitada
                    min = minAux
                    cidadeVisitada = j
                    /*console.log("cidadesVisitadasFORJ: ", cidadeVisitada)
                    console.log("custoMIN: ", custoMin, " i: ",i, " j: ",j) */
                /*}*/
            }
            //console.log("custo: ", custo)
            //}
            
            //console.log("custo_ANTES SORT: ", custo)
            //ordenar os custos do menor para o maior 
            custo.sort(function (a, b) { return a - b });
            //custo.reverse()
            //console.log("custo SORT: ", custo)
            i=0
            var custoAux 
            //saber os indices dos custos (cidades) na matriz
            //for (m = 0; m < matriz.length; m++) {
            for (m = 0; m < custo.length; m++) {
                for (j = 1; j < matriz.length; j++) {
                    //console.log("m: ", m, "j: ",j, "custom: ", custo[m])

                    custoAux = matriz[j][caminho[0]] + matriz[caminho[1]][j]
                    //console.log("custoAux: ",custoAux)

                    //capturar o indice do valor ordenado
                    if (custo[m] == custoAux && caminho.includes(j) == false && cidadeVisitadaAux.includes(j) == false && m != j) { 
                        cidadeVisitada = j
                        cidadeVisitadaAux.push(cidadeVisitada)

                        //console.log("cidadesVisitadas_IF: ", cidadeVisitadaAux)
                    }
                }

            }
            //console.log("SAI 2FOR")
            //indices iniciais do caminhoij sao os mais pertos da cidade onde estou
            indice = parseInt((cidadeVisitadaAux.length / 2), 10) //indice da metade do vetor
            //console.log("indice", indice)

            //rand do indice para capturar o elemento a ser inserido no array CAMINHO
            //capturar um dos menores custos aleatoriamente
            //Math.floor(Math.random() * 100);     // returns a random integer from 0 to 99
            indiceEscolhido = Math.floor(Math.random() * indice);

            //console.log("cidadeVisitadaAux: ", cidadeVisitadaAux)
            //console.log("indiceEscolhido", cidadeVisitadaAux[indiceEscolhido])

            //inserir o indice(cidade) no array de caminho Final
            //if (caminho.includes(cidadesVisitadas[indiceEscolhido]) == false) {
            caminho.push(cidadeVisitadaAux[indiceEscolhido])
            
            //Apos inserir a cidade 3, fecha o ciclo ->voltando para a cidade origem
            caminho.push(0)

            //Tirar a cidade escolhida do array de cidades nao visitadas
            cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitadaAux[indiceEscolhido]), 1)
                
                /*if (S == (tam - 2)) { //ultima cidade visitada
                    caminho.push(cidadeVisitada)//insiro a cidade visitada no array
                    caminho.push(0)//fechando o ciclo ->voltando para a cidade origem
                    cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitada), 1)
                    //custoCaminhoMaisBarato.push(custoMin)
                    //console.log("cidadesVisitadasIFS: ", cidadeVisitada)
                }
                */
            //}
            //console.log("caminho_PASSO2: ", caminho)
            //console.log("cidadesNAOvisitadas_PASSO2: ", cidadesNAOvisitadas)

            //=================================FIM==PASSO2======================================

            //======================================PASSO3======================================
            //Das cidades nao visitadas, calcular o custo de insercao e inserir a cidade com menor custo
            //insere entre as cidades ja escolhidas, diminuindo o custo do percurso total
            //console.log("PASSO3")
            min = Number.MAX_VALUE
            minAux = 0
            //console.log("caminho: ",caminho.length)
            var cidadesNAOvisitadasAux = cidadesNAOvisitadas.length
            let cidadei, cidadej

            for (S = 0; S < cidadesNAOvisitadasAux; S++) {//percorrer as cidades
                for (l = 0; l < caminho.length - 1; l++) {
                    i = caminho[l]
                    j = caminho[l + 1]
                    //console.log("l: ",l)

                    for (m = 0; m < cidadesNAOvisitadas.length; m++) {
                        k = cidadesNAOvisitadas[m]
                        //console.log("# i: ", i, " j: ", j, " k: ", k)
                        //console.log("matriz[i][k]: ", matriz[i][k], " matriz[k][j]: ", matriz[k][j], "matriz[i][j]", matriz[i][j])
                        minAux = (matriz[i][k] + matriz[k][j]) - matriz[i][j]

                        if (minAux < min) {
                            //console.log("# i: ", i, " j: ", j, " k: ", k)
                            min = minAux
                            cidadeVisitada = k
                            cidadei = i
                            cidadej = j

                            //console.log("min_PASSO3: ", min, " i: ",i," j: ",j, " k: ",k)
                        }
                    }
                }
                //console.log("cidadei: ",cidadei, " cidadej: ",cidadej, " k: ", cidadeVisitada)
                caminho.splice(caminho.indexOf(cidadei) + 1, 0, cidadeVisitada)
                //console.log("MATRIZ[ik]: ",matriz[cidadei][cidadeVisitada], " MATRIZ[kj]: ", matriz[cidadeVisitada][cidadej], " MATRIZ[ij]: ", matriz[cidadei][cidadej])
                //console.log("S: ",S, " - min_PASSO3: ", min, "cidade visitada: ",cidadeVisitada)

                cidadesNAOvisitadas.splice(cidadesNAOvisitadas.indexOf(cidadeVisitada), 1)
                min = Number.MAX_VALUE
            }
            //console.log("cidadeVisitada_PASSO3: ", cidadeVisitada)
            //console.log("caminho_PASSO3: ", caminho)
            //=================================FIM==PASSO3======================================
            
            var somaCaminhoMaisBarato = somarCustoCaminho(matriz,caminho)
        
            //console.log("somaCaminhoMaisBarato: ", somaCaminhoMaisBarato)
            //exibeResultado(somaMenorCaminho)
            let retorno = []
            retorno.push(caminho,somaCaminhoMaisBarato)
            //console.log("caminho: ", caminho, "custo: ", somaCaminhoMaisBarato)
            //return somaCaminhoMaisBarato, caminho
            return retorno
            
        }
        

        //funcao para o calculo do custo apos a troca dos vertices
        function swap2opt(matriz,caminho,custoOriginal,i,j){ 
            let caminhoParcial = copiaVetor(caminho)
            //let caminhoParcial = []
            let valorParcial = custoOriginal
            let caminhoAux = []
            var k = i,l = j
            let caminhoReverso = []
            let caminhoMeio = []
            //console.log("aux:::: ", aux)
            
            //de 0 ate i-1 nao muda
            for(k = 0; k < i; k++){
                caminhoAux.push(caminho[k])
            }
            //console.log("caminhoAuxINICIO: ",caminhoAux, " i: ",i," j: ",j)

            //capturar os elementos entre i e j (k-l) a serem invertidos
            for(k=i;k<=j;k++){
                caminhoMeio.push(caminhoParcial[k])
            }
            //console.log("caminhoMEIO: ", caminhoMeio, " i: ", i, " j: ", j)

            caminhoReverso = caminhoMeio.reverse() //inverter o vetor do meio

            //console.log("caminhoMEIO_REVERSO: ", caminhoReverso, " i: ", i, " j: ", j)
            for(k=i; k <= j; k++){
                caminhoAux.push(caminhoReverso[k-i]) //percorrer todo o camiho inverso de i ate j
                //caminhoAux.push(caminhoReverso[k])
            }
            //console.log("caminhoAuxMEIO: ", caminhoAux)

            for(k = j + 1; k < caminho.length; k++){
                caminhoAux.push(caminhoParcial[k])
            }
            //console.log("caminhoParcial: ", caminhoAux)
            //console.log("valorParcial: ", valorParcial, " Caminho: ", caminhoParcial, " i: ", i, " j: ", j, " elementoi: ", caminhoParcial[i], " elementoj: ", caminhoParcial[j])
            
            valorParcial = somarCustoCaminho(matriz, caminhoAux)

            var retorno = []
            retorno.push(caminhoAux,valorParcial)
            return retorno
            
        }

        function opt2(matriz,caminho,custoOriginal){
            var i,j
            
            let menorCusto = custoOriginal
            //console.log("OPT-custo: ", menorCusto)
            let menorCustoAux
            let caminhoAux = copiaVetor(caminho)
            let flagOPT = false
            
            //console.log("caminhoOrig: ", caminho)
            
            for(i = 1; i < (caminho.length - 1); i++){ //inicio do indice 1 pois o 0 eh o inicio
                for((j = i + 1); j < (caminho.length - 1); j++){
                    menorCustoAux = swap2opt(matriz, caminhoAux, menorCusto, i, j)
                    //console.log("menorCusto: ", menorCustoAux)
                    if(menorCustoAux[1] < menorCusto){
                        //console.log("menorCustoAux: ", menorCustoAux[1], " caminho: ", menorCustoAux[0])
                        menorCusto = menorCustoAux[1]
                        caminhoAux = menorCustoAux[0]
                    }   
                }
                
            }

            //console.log("Caminho: ", caminhoAux, " menorCusto: ", menorCusto)
            let retorno = []
            retorno.push(caminhoAux, menorCusto)
            
            return retorno
        }

        function swapVertice(matriz, caminho, custoOriginal, i, j) {
            let caminhoParcial = copiaVetor(caminho)
            let valorParcial = custoOriginal
            let aux

            aux = caminhoParcial[i]
            //.log("caminhoAUXi: ",aux)
            //tirar o elemento da sua posicao 
            // splice(indice a ser add ou removido ,qntde de itens a ser removido,itens a serem add)
            caminhoParcial.splice(i, 1) //remover o item do vetor na posicao desejada
            //console.log("removi: ", caminhoAux)
            caminhoParcial.splice(j, 0, aux) //add o item do vetor na posicao desejada
            //console.log("inseri: ", caminhoParcial, "i: ", i,"j: ",j)
            //caminhoAuxRes = copiaVetor(caminhoAux)
            valorParcial = somarCustoCaminho(matriz, caminhoParcial)

            var retorno = []
            retorno.push(caminhoParcial, valorParcial)

            return retorno
        }

        function reinsertion(matriz, caminho, custoOriginal){
            //console.log("REINSERTION ON..")
            var i, j
            let menorCusto = custoOriginal
            let menorCustoAux = []
            let caminhoAuxRes = []
            let caminhoAux = copiaVetor(caminho)
            var aux
            //console.log("CAMINHO ", caminhoAux)
            //let flagReinsertion = false

            for (i = 1; i < (caminho.length - 1); i++) { //inicio do indice 1 pois o 0 eh o inicio 
                for (j = 1; j < (caminho.length - 1); j++) {
                    if(i != j){ //para nao mudar o item para a mesma posicao
                        
                        //console.log("ENTREI...")

                        menorCustoAux = swapVertice(matriz, caminhoAux, menorCusto, i, j)
                        
                    }
                    //console.log("menor custo aux: ",menorCustoAux)
                    
                    //console.log("CUSTOMENOR: ", menorCustoAux)
                    
                    //caminhoAux.splice(caminhoAux.indexOf(i), 1) //add o vetor na posicao desejada
                    
                    //inserir o elemento em outra posicao
                    //               (indice a ser add ou removido, 0 = add, itens a serem add)
                    //caminhoAux.splice(caminhoAux.indexOf(i), 0, caminhoAux(i)) //add o vetor na posicao desejada

                    //console.log("menorCusto: ", menorCustoAux)
                    if (menorCustoAux[1] < menorCusto) {
                        //console.log("menorCustoAux: ", menorCustoAux[1], " caminho: ", menorCustoAux[0])
                        menorCusto = menorCustoAux[1]
                        caminhoAux = copiaVetor(menorCustoAux[0])  
                        //flag = true
                    }/* else{
                        flag = false
                    } */
                }
            }
            /* if(menorCusto < custoOriginal){
                flag = true
            }else{
                flag = false
            } */
            //console.log("Caminho: ", caminhoAux, " menorCusto: ", menorCusto)
            let retorno = []
            retorno.push(caminhoAux, menorCusto)

            return retorno
        }

        function VND(matriz, vetorCusto){
            //let flag = true

            /* let flag2OPTMin = true
            let flag2OPTMax = true
            let flag2OPTBarato = true */

            let flag2opt = true
            let flagReinsertion = true

            let OPT2 = []
            let REINSERTIONN = []
            
            /* let backup2opt = copiaVetor(opt2)
            let backupreinsertion = copiaVetor(reinsertion) */

            //let minCustoReinsertionRes = copiaVetor(minReinsertion) 

            //      flag
            while((flag2opt == true) || (flagReinsertion == true)){
                //let i = 0
                //                           caminho         custo
                //OPT = opt2(matriz, vetorCusto[0], vetorCusto[1])
                REINSERTIONN = reinsertion(matriz, vetorCusto[0], vetorCusto[1])

                if(REINSERTIONN[1] < vetorCusto[1]){
                    flagReinsertion = true
                    vetorCusto = copiaVetor(REINSERTIONN)
                    //console.log("vetorCustoIF: ", vetorCusto[1])
                }else{
                    flagReinsertion = false
                    OPT2 = opt2(matriz, vetorCusto[0], vetorCusto[1])

                    if(OPT2[1] < vetorCusto[1]){
                        flag2opt = true
                        vetorCusto = copiaVetor(OPT2)
                        //console.log("IF2OPT")

                    }else{
                        flag2opt = false
                        //console.log("flag2opt: ", flag2opt)
                        //console.log("flagReinsertion: ", flagReinsertion)
                        //i++
                        //console.log("i: ", i)
                    }
                    
                }
            } 
            //console.log("vetorCusto: ", vetorCusto[1])
            
            //console.log("Caminho: ", caminhoAux, " menorCusto: ", menorCusto)
            let retorno = []
            retorno.push(vetorCusto[0], vetorCusto[1])

            return retorno
        }

        function multiStart(matriz, tam){
            let custo = Number.MAX_VALUE
            let i = 0
            let s = []
            let melhorSolucao = []
            
            while(i < 100){
                if(i < 34){
                    s = minCaminhoAleatorio2(matriz, tam)
                }    
                else if(i > 33 && i < 67 ){
                    s= maxCaminhoAleatorio2(matriz, tam)
                }
                else if(i > 66 && i < 100){
                    s = caminhoMaisBaratoAleatorio(matriz, tam)
                } 

                s = VND(matriz, s)

                // [0] = caminho e [1] = custo
                if(s[1] < custo){
                    melhorSolucao = copiaVetor(s)
                    custo = s[1]
                }

                i++
                //console.log(i)
            }

            s = copiaVetor(melhorSolucao) 
            console.log("MS - ", "custo: ", s[1],"\ncaminho: ",s[0])
            exibeResultado(s)
        }

        function unidade3(A) {
            var i, j, k=1
            
            //console.log(A)

            let tam = A[0]//tamanho da matriz
            //console.log("tam: ",tam)
            
            let matriz = new Array(tam).fill(0) //criar as linhas
            matriz = matriz.map(linha => new Array(tam).fill(0)) //criar as colunas

            //console.log(matriz)

            for(i=0;i<tam-1;i++){
                for(j=i+1;j<tam;j++){
                    matriz[i][j] = A[k]
                    matriz[j][i] = A[k]
                    k++
                }
            }
            console.log("matriz: ",matriz)
            
            /* let caminhoMin = minCaminho(matriz, tam)
            let caminhoMax = maxCaminho(matriz, tam)
            let caminhoBarato = caminhoMaisBarato(matriz, tam)
            let escolhido = [] */
            //let teste = [0, 5, 1, 2, 3, 4, 0]
            
            //console.log("caminhoMin: ", caminhoMin, " caminhoMax: ", caminhoMax, " caminhoBarato: ", caminhoBarato)

            /* let min2Opt = opt2(matriz, caminhoMin[0], caminhoMin[1])
            let max2Opt = opt2(matriz, caminhoMax[0], caminhoMax[1])
            let barato2Opt = opt2(matriz, caminhoBarato[0], caminhoBarato[1])

            let minReinsertion = reinsertion(matriz,caminhoMin[0], caminhoMin[1])
            let maxReinsertion = reinsertion(matriz, caminhoMax[0], caminhoMax[1])
            let baratoReinsertion = reinsertion(matriz, caminhoBarato[0], caminhoBarato[1]) */

            //let menorCusto
            /* if((caminhoMin[1] <= caminhoMax[1]) && (caminhoMin[1] <= caminhoBarato[1])){
                escolhido = copiaVetor(caminhoMin)
            }
            else if (caminhoMax[1] <= caminhoMin[1] && caminhoMax[1] <= caminhoBarato[1]){
                escolhido = copiaVetor(caminhoMax)
            }
            else if (caminhoBarato[1] <= caminhoMax[1] && caminhoBarato[1] <= caminhoMax[1]){
                escolhido = copiaVetor(caminhoBarato)
            }
            console.log("escolhido: ",escolhido) */

            //                         caminho        custo
            
            /* console.log("2-OPT:")
            console.log("Min: ", min2Opt[0], "custo: ", min2Opt[1])
            console.log("Max: ", max2Opt[0], "custo: ", max2Opt[1])
            console.log("Barato: ", barato2Opt[0], "custo: ", barato2Opt[1])
            console.log("flagMin: ", min2Opt[2])
            console.log("REINSERTION:")
            console.log("Min: ", minReinsertion[0], "custo: ", minReinsertion[1])
            console.log("Max: ", maxReinsertion[0], "custo: ", maxReinsertion[1])
            console.log("Barato: ", baratoReinsertion[0], "custo: ", baratoReinsertion[1]) */

            //console.log("menorCaminho: ",menorCusto[0], "menorCusto: ", menorCusto[1]) 

            //exibeResultado(min,caminhoMax,maisBarato)

            //console.log("VND: ",VND(matriz,tam))
            
            //let minReinsertion = reinsertion(matriz,caminhoMin[0], caminhoMin[1])
            //console.log("Min: ", minReinsertion[0], "custo: ", minReinsertion[1])
            //let min2Opt = opt2(matriz, caminhoMin[0], caminhoMin[1])
            
            /* let barato2Opt = opt2(matriz, caminhoBarato[0], caminhoBarato[1])
            console.log("2OPT - "," Barato: ", barato2Opt[0], "custo: ", barato2Opt[1])
            let baratoReinsertion = reinsertion(matriz, caminhoBarato[0], caminhoBarato[1])
            console.log("REINSERTION - "," Barato: ", baratoReinsertion[0], "custo: ", baratoReinsertion[1]) */

            /* let VndRES = VND(matriz, caminhoBarato)
            console.log("VndRES - "," custo: ", VndRES[1], "caminho: ",VndRES[0]) */
            
            /* let caminho = [1,2,3,4,5]
            console.log(caminho)
            //let itemCaminho = caminho.indexOf(1)
            i=1
            let itemCaminho = i
            var aux
            aux = caminho[i]
            caminho.splice(itemCaminho, 1) //remover o item do vetor na posicao desejada
            console.log(caminho)
            caminho.splice(3, 0, aux) //add o item do vetor na posicao desejada
            console.log(caminho) */

            /* let caminhoMin = minCaminho(matriz, tam)
            console.log("CHAMANDO REINSERTION...")
            let minReinsertion = reinsertion(matriz, caminhoMin[0], caminhoMin[1])
            console.log("FIM REINSERTION...")
            console.log("Min: ", minReinsertion[0], "custo: ", minReinsertion[1]) */
            multiStart(matriz, tam)

            /*let caminhoMin = minCaminhoAleatorio2(matriz, tam)
            console.log("caminhoMin: ", caminhoMin[0], "Custo: ", caminhoMin[1])
            let caminhoMax = maxCaminhoAleatorio2(matriz, tam)
            console.log("caminhoMax: ", caminhoMax[0], "Custo: ", caminhoMax[1]) 
            let caminhoBarato = caminhoMaisBaratoAleatorio(matriz, tam)
            console.log("Barato: ", caminhoBarato[0], "custo: ", caminhoBarato[1])
            */
        } 

        function exibeResultado(s) {
            //mostrar o resultado ordenado
            var count = 0
            var strDivResultado = ""
            var i
            
            strDivResultado += '<table>';
            
            strDivResultado += '<tr>';
            strDivResultado += '<td>' + "Multi Start - Custo: " + s[1] +'</td>';
            strDivResultado += '</tr>';
            strDivResultado += '<tr>';
            strDivResultado += '<td>' + "Caminho: " +s[0]+ '</td>';
            strDivResultado += '</tr>';
            strDivResultado += '<tr>';

            /* for(i=0;i<s.length;i++){
                strDivResultado += '<td>' + s[0] +' - '+ '</td>';
            } */
            
            strDivResultado += '</tr>';

            strDivResultado += '</table>'
            var exibeResultado = document.getElementById('exibeResultado');
            exibeResultado.innerHTML = strDivResultado;
        }

        //capturar arquivo

        var leitorDeCSV = new FileReader()
        window.onload = function init() {
            leitorDeCSV.onload = leCSV;
        }

        function pegaCSV(inputFile) {
            var file = inputFile.files[0];
            leitorDeCSV.readAsText(file);
        }

        function leCSV(evt) {

            var fileArr = evt.target.result.split('\n');
            //var fileArr = evt.target.result;
            /* console.log("fileArr: ", fileArr)
            var re = /\s* \s*/
            /*var fileArrSplit = fileArr.split(re);
            console.log("fileArr: ", fileArrSplit) */
            
            var strDiv = '<table>';
            strDiv += '<tr>';
            var indice = 0
            var maiorNumero = 0
            
            for (var i = 0; i < fileArr.length; i++) {
                //strDiv += '<tr>';
                //var fileLine = fileArr[i].split(',');
                //var fileLine = fileArr[i].split(' ');
                var fileLine = fileArr[i].split(" ");
                    for (var j = 0; j < fileLine.length; j++) {
                        //strDiv += '<td>' + "valor |"+fileLine[j].trim() +"|"+ '</td>';
                        /* if (maiorNumero < parseInt(fileLine[j], 10)) {
                            maiorNumero = parseInt(fileLine[j], 10)

                            //strDiv += '<td>' + "Array: " + array[j] + "j = " + j + '</td>'
                            //strDiv += '<td>' + "indice = |" + indice + "|" + '</td>';

                        } */
                        //if(fileLine[j] != NaN){
                            
                            array.push(parseInt(fileLine[j], 10))
                        //}
                        
                        //strDiv += '<td>' + "j = |" + j + "|" + '</td>';
                        //strDiv += '<td>' + array[indice] + ", " + '</td>';

                        //indice++

                    }
                //}
                
            }
            
            //strDiv += '<tr>';
            //strDiv += '<td>' + "Quantidade de linhas: " + fileArr.length + '</td>';
            //strDiv += '</tr>';

            strDiv += '</table>';
            var CSVsaida = document.getElementById('CSVsaida');
            CSVsaida.innerHTML = strDiv;

            console.log("array: ",array)
            unidade3(array)
        }
    </script>

</body>

</html>